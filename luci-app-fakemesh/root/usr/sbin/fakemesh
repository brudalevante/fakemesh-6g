#!/bin/sh

. /lib/functions.sh
. /lib/functions/network.sh

config_load fakemesh

config_get_bool enabled default 'enabled' '0'

test $enabled -eq 0 && {
	rm -f /tmp/fakemesh.ac.config
	rm -f /etc/config/fakemeshac
	rm -rf /tmp/fakemesh_lck*
	uci delete wireless.meshx0 >/dev/null 2>&1
	uci delete wireless.meshx1 >/dev/null 2>&1

	uci set dhcp.lan.ignore='0'
	uci delete dhcp.meshx0 >/dev/null 2>&1
	uci delete network.meshx0 >/dev/null 2>&1
	uci delete firewall.fakemesh >/dev/null 2>&1
	sed -i "/.* controller.fakemesh/d" /etc/hosts
	sed -i "/sh \/usr\/share\/fakemesh\/firewall.include.*/d" /etc/firewall.include

	#re-enable lan
	uci delete network.lan.auto >/dev/null 2>&1
	#re-enable wan
	uci delete network.wan.auto >/dev/null 2>&1
	uci delete network.wan6.auto >/dev/null 2>&1
	#del wan port from br-lan
	lan_idx=0
	while uci get network.@device[$lan_idx] >/dev/null 2>&1 && [ $(uci get network.@device[$lan_idx].name) != "br-lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_ports="$(uci get network.@device[$lan_idx].ports 2>/dev/null)"
	wan_port="$(uci get network.wan.device 2>/dev/null)"
	newlan_ports=$(for lp in $lan_ports; do [ "$lp" = "$wan_port" ] || echo $lp; done | sort | uniq)
	newlan_ports=$(echo $newlan_ports)
	[ "$lan_ports" != "$newlan_ports" ] && {
		uci delete network.@device[$lan_idx].ports >/dev/null 2>&1
		for lp in $newlan_ports; do
			uci add_list network.@device[$lan_idx].ports="$lp"
		done
	}

	#delete meshx0 from lan zone
	lan_idx=0
	while uci get firewall.@zone[$lan_idx] >/dev/null 2>&1 && [ $(uci get firewall.@zone[$lan_idx].name) != "lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_net="$(uci get firewall.@zone[$lan_idx].network 2>/dev/null)"
	newlan_net=$(for ln in $lan_net; do [ "$ln" = "meshx0" ] || echo $ln; done | sort | uniq)
	newlan_net=$(echo $newlan_net)
	[ "$lan_net" != "$newlan_net" ] && {
		uci delete firewall.@zone[$lan_idx].network >/dev/null 2>&1
		for ln in $newlan_net; do
			uci add_list firewall.@zone[$lan_idx].network="$ln"
		done
		uci commit firewall
	}

	uci changes

	uci commit wireless
	uci commit dhcp
	uci commit firewall
	uci commit network
	/etc/init.d/network reload
	/etc/init.d/dnsmasq reload
	/etc/init.d/firewall reload >/dev/null 2>&1
	exit 0
}

config_get role default 'role' 'agent'
config_get band default 'band' '5g'
config_get id default 'id'
config_get key default 'key'
config_get access_ip default 'access_ip' '10.10.10.1'
config_get sync_ac default 'sync_ac' '1'

lost_ac=${lost_ac:-0}
LOST_AC_CNT=3

agent_lost_ac()
{
	[ "$role" = "agent" ] || [ "$role" = "wap" ] || return 0

	pid=$$
	logger -t fakemesh "agent_lost_ac($pid): started! lost_ac=$lost_ac"

	if test $lost_ac -gt $LOST_AC_CNT; then
		rm -rf /tmp/fakemesh_lck3
		lost_ac=$lost_ac exec /usr/sbin/fakemesh agent_sync_config &
		return 0
	fi

	#re-enable lan
	uci delete network.lan.auto >/dev/null 2>&1
	uci set network.lan.ipaddr="192.168.1.1"
	for lip in `seq 1 16`; do
		if ip route | grep -q "192.168.$lip.0/"; then
			:
		else
			uci set network.lan.ipaddr="192.168.$lip.1"
			break
		fi
	done
	uci set network.lan.netmask='255.255.255.0'
	logger -t fakemesh "agent_lost_ac($pid): setup temporary lan ip=$(uci get network.lan.ipaddr)"

	#re-enable lan dhcp
	uci set dhcp.lan.ignore='0'
	#re-enable lan enable wifi
	ssid=$(uci get base_config.@status[0].SSID)
	ssid_passwd=$(uci get base_config.@status[0].SSID_PASSWD)
	K=0
	for band in 2g 5g; do
		wbandstr=$(uci show wireless | grep .band=\'${band}\'$ | head -n1)
		if test -n "$wbandstr"; then
			radio=$(echo $wbandstr | cut -d\. -f2)

			uci set wireless.wifinet$K=wifi-iface
			uci set wireless.wifinet$K.device="${radio}"
			uci set wireless.wifinet$K.network='lan'
			uci set wireless.wifinet$K.mode='ap'
			uci set wireless.wifinet$K.ssid="${ssid}"
			uci set wireless.wifinet$K.encryption="psk2"
			uci set wireless.wifinet$K.key="${ssid_passwd}"
			uci set wireless.wifinet$K.skip_inactivity_poll='1'
			uci set wireless.wifinet$K.wpa_group_rekey='0'
			uci set wireless.wifinet$K.wpa_pair_rekey='0'
			uci set wireless.wifinet$K.wpa_master_rekey='0'
			uci set wireless.wifinet$K.disassoc_low_ack='0'
			uci set wireless.wifinet$K.disabled='0'
			K=$((K+1))
		fi
	done
	while uci get wireless.wifinet$K 2>/dev/null; do
		uci set wireless.wifinet$K.disabled='1'
		K=$((K+1))
	done

	logger -t fakemesh "agent_lost_ac($pid): starting wifi SSID=\'${ssid}\' on ${radio} $band!"

	/etc/init.d/network reload
	/etc/init.d/dnsmasq reload
	sleep 5
	uci revert dhcp
	uci revert network
	uci revert wireless

	logger -t fakemesh "agent_lost_ac($pid): done!"

	#make sure agent_sync_config stopped
	rm -rf /tmp/fakemesh_lck3
	lost_ac=$lost_ac exec /usr/sbin/fakemesh agent_sync_config &
}

agent_sync_config()
{
	[ "$sync_ac" = "1" ] || {
		rm -f /etc/config/fakemeshac
		return 0
	}
	[ "$role" = "wap" ] && {
		#make sure agent_keep_alive stopped
		rm -rf /tmp/fakemesh_lck2*
	}

	mkdir /tmp/fakemesh_lck3 || return 0
	pid=$$
	touch /tmp/fakemesh_lck3/$pid

	logger -t fakemesh "agent_sync_config($pid): started!"

	touch /tmp/fakemesh.ac.config
	ln -s /tmp/fakemesh.ac.config /etc/config/fakemeshac 2>/dev/null

	while :; do
		sleep 10
		if test $lost_ac -gt 2; then
			ubus call network.interface.meshx0 down
			sleep 1
			ubus call network.interface.meshx0 up
			sleep 1
		fi

		hash=$(echo -n $id$key | md5sum | head -c32)
		if ( \
		[ "$role" = "controller" ] && cp /etc/config/fakemesh /tmp/fakemesh.ac.config.tmp || \
		timeout 30 wget -qO /tmp/fakemesh.ac.config.tmp http://controller.fakemesh/fakemesh.$hash ); then
			:
		else
			lost_ac=$((lost_ac+1))
			logger -t fakemesh "agent_sync_config($pid): fetch config failed($lost_ac)!"
			if test $lost_ac -ge $LOST_AC_CNT; then
				lost_ac=$lost_ac exec /usr/sbin/fakemesh agent_lost_ac &
				return 0
			fi
			sleep 30
			rm -f /tmp/fakemesh.ac.config.tmp
			test -f /tmp/fakemesh_lck3/$pid || return 0
			continue
		fi

		mv /tmp/fakemesh.ac.config.tmp /tmp/fakemesh.ac.config

		test $lost_ac -gt 0 && logger -t fakemesh "agent_sync_config($pid): fetch config ok!"

		oldcfgmd5=$(uci get fakemesh.default.wifim_md5 2>/dev/null)
		newcfgmd5=$(uci show fakemeshac | grep "^fakemeshac.@wifim" | md5sum | head -c 32)
		[ "${oldcfgmd5}" = "${newcfgmd5}" ] || {
			logger -t fakemesh "agent_sync_config($pid): config change!"
			#delete old wifi config
			I=0
			while uci get wireless.@wifi-iface[$I] >/dev/null 2>&1; do
				if uci show wireless.@wifi-iface[$I] | grep -q wireless.meshx[01]=wifi-iface; then
					I=$((I+1))
					continue
				fi
				uci delete wireless.@wifi-iface[$I] >/dev/null 2>&1
			done

			J=0
			K=0
			while uci get fakemeshac.@wifim[$J] >/dev/null 2>&1; do
				ssid=$(uci get fakemeshac.@wifim[$J].ssid)
				encryption=$(uci get fakemeshac.@wifim[$J].encryption)
				key=$(uci get fakemeshac.@wifim[$J].key)
				bands=$(uci get fakemeshac.@wifim[$J].band)
				enabled=$(uci get fakemeshac.@wifim[$J].enabled || echo 1)

				[ "$bands" = "2g5g" ] && bands="2g 5g"

				[ "$enabled" = "1" ] && {
					for band in $bands; do
						wbandstr=$(uci show wireless | grep .band=\'${band}\'$ | head -n1)
						if test -n "$wbandstr"; then
							radio=$(echo $wbandstr | cut -d\. -f2)

							uci set wireless.wifinet$K=wifi-iface
							uci set wireless.wifinet$K.device="${radio}"
							if [ "$role" = "controller" ]; then
								uci set wireless.wifinet$K.network='lan'
							else
								uci set wireless.wifinet$K.network='meshx0'
							fi
							uci set wireless.wifinet$K.mode='ap'
							uci set wireless.wifinet$K.ssid="${ssid}"
							if [ "${encryption}" != "none" ]; then
								uci set wireless.wifinet$K.encryption="${encryption}"
								uci set wireless.wifinet$K.key="${key}"
							else
								uci set wireless.wifinet$K.encryption='none'
							fi
							uci set wireless.wifinet$K.skip_inactivity_poll='1'
							uci set wireless.wifinet$K.wpa_group_rekey='0'
							uci set wireless.wifinet$K.wpa_pair_rekey='0'
							uci set wireless.wifinet$K.wpa_master_rekey='0'
							uci set wireless.wifinet$K.disassoc_low_ack='0'
							uci set wireless.wifinet$K.ieee80211r='1'
							uci set wireless.wifinet$K.ft_over_ds='1'
							uci set wireless.wifinet$K.ft_psk_generate_local='1'

							K=$((K+1))
						fi
					done
				}

				J=$((J+1))
			done

			uci set fakemesh.default.wifim_md5="${newcfgmd5}"

			uci commit fakemesh
			uci commit wireless
			/etc/init.d/network reload &
		}

		test -f /tmp/fakemesh_lck3/$pid || return 0

		if test $lost_ac -ge $LOST_AC_CNT; then
			logger -t fakemesh "agent_sync_config($pid): recovery from lost_ac=$lost_ac!"
			sleep 5
			/etc/init.d/network reload
			/etc/init.d/dnsmasq reload
		fi
		lost_ac=0

		rand=$(hexdump -e '"%u"' -n1 /dev/urandom)
		sleep $((50+(rand+0)%20))
		test -f /tmp/fakemesh_lck3/$pid || return 0
	done

	rm -f /tmp/fakemesh_lck3/$pid; rmdir /tmp/fakemesh_lck3
}

agent_keep_alive()
{
	[ "$role" = "agent" ] || return 0

	sta_lost=0

	wbandstr=$(uci show wireless | grep .band=\'${band}\'$ | head -n1)
	radio=$(echo $wbandstr | cut -d\. -f2)
	channel=$(uci get wireless.${radio}.channel)
	test -n "$channel" || return 1

	mkdir /tmp/fakemesh_lck2 || return 0
	pid=$$
	touch /tmp/fakemesh_lck2/$pid

	logger -t fakemesh "agent_keep_alive($pid): started!"
	while :; do
		sleep 10
		sta="$(ubus -S list wpa_supplicant.meshx1)"
		if test -n "$sta"; then
			if [ $(iwinfo meshx1 info | grep -c 'ESSID: unknown') -ge 1 ]; then
				sta_lost=$((sta_lost+1))
				if [ "$sta_lost" -ge 3 ]; then
					logger -t fakemesh "agent_keep_alive($pid): Agent lost connection!"
					rm -f /tmp/fakemesh_lck2/$pid; rmdir /tmp/fakemesh_lck2
					exec /usr/sbin/fakemesh agent_fix_channel &
					return 0
				fi
			elif [ "$(iwinfo meshx1 info | head -n3 | tail -n1 | awk '{print $4}')" != "$channel" ]; then
				logger -t fakemesh "agent_keep_alive($pid): Agent channel changed!"
				rm -f /tmp/fakemesh_lck2/$pid; rmdir /tmp/fakemesh_lck2
				exec /usr/sbin/fakemesh agent_fix_channel &
				return 0
			fi
		fi
		sleep 30
		test -f /tmp/fakemesh_lck2/$pid || return 0
	done

	rm -f /tmp/fakemesh_lck2/$pid; rmdir /tmp/fakemesh_lck2
}

agent_fix_channel()
{
	exec /usr/sbin/fakemesh agent_sync_config &

	[ "$role" = "agent" ] || return 0

	wbandstr=$(uci show wireless | grep .band=\'${band}\'$ | head -n1)
	radio=$(echo $wbandstr | cut -d\. -f2)
	channel=$(uci get wireless.${radio}.channel)
	test -n "$channel" || return 1

	mkdir /tmp/fakemesh_lck1 || return 0
	pid=$$
	touch /tmp/fakemesh_lck1/$pid

	logger -t fakemesh "agent_fix_channel($pid): started!"
	while :; do
		sleep 10
		sta="$(ubus -S list wpa_supplicant.meshx1)"
		if test -n "$sta"; then
			chan=$(iwinfo meshx0 scan | grep -A1 -B1 "ESSID: \"${id}\"" | head -n3 | tail -n1 | awk '{print $4}')
			if test -n "$chan"; then
				if [ "$chan" != "$channel" ]; then
					logger -t fakemesh "agent_fix_channel($pid): Setting up channel ($chan) for ${radio}"
					uci set wireless.${radio}.channel="$chan"
					uci commit wireless
					/etc/init.d/network reload &
				fi
				logger -t fakemesh "agent_fix_channel($pid): Channel ($chan) for ${radio} ready!"
				break
			fi
		fi
		sleep 20
		test -f /tmp/fakemesh_lck1/$pid || return 0
	done

	rm -f /tmp/fakemesh_lck1/$pid; rmdir /tmp/fakemesh_lck1

	exec /usr/sbin/fakemesh agent_keep_alive &
}

[ "x$1" = "xagent_lost_ac" ] && {
	agent_lost_ac
	exit 0
}

[ "x$1" = "xagent_fix_channel" ] && {
	agent_fix_channel
	exit 0
}

[ "x$1" = "xagent_keep_alive" ] && {
	agent_keep_alive
	exit 0
}

[ "x$1" = "xagent_sync_config" ] && {
	agent_sync_config
	exit 0
}

[ "x$1" = "xgen_config" ] && {
	# http://controller.fakemesh/fakemesh.435ca8a686ae9f07eb4eb67d2216b154
	[ "$role" = "controller" ] && {
		hash=$(echo -n $id$key | md5sum | head -c32)
		ln -s /etc/config/fakemesh /www/fakemesh.$hash 2>/dev/null
		for f in $(ls /www/fakemesh.*); do
			[ "$f" != "/www/fakemesh.$hash" ] && rm -f "$f"
		done
	}
	exit 0
}

test -n "$id" || {
	exit 0
}

rm -rf /tmp/fakemesh_lck*

MACADDR=""
test -e /usr/share/natcapd/board_mac.lua && MACADDR=`lua /usr/share/natcapd/board_mac.lua`
test -n "$MACADDR" || MACADDR=`cat /etc/board.json | grep macaddr | tr a-f A-F | grep -o "[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]:[0-9A-F][0-9A-F]" | head -n1`
test -n "$MACADDR" || MACADDR=`cat /sys/class/net/eth0/address | tr a-z A-Z`
test -n "$MACADDR" || MACADDR=`cat /sys/class/net/eth1/address | tr a-z A-Z`
test -n "$MACADDR" || MACADDR=`head -c6 /dev/urandom | hexdump -e '/1 "%02X:"' | head -c17`
test -n "$MACADDR" || MACADDR=`head -c6 /dev/random | hexdump -e '/1 "%02X:"' | head -c17`

if [ "$role" = "controller" ]; then

	rm -rf /tmp/fakemesh_lck*

	# wireless.radio0.band='2g'
	wbandstr=$(uci show wireless | grep .band=\'${band}\'$ | head -n1)
	if test -n "$wbandstr"; then
		radio=$(echo $wbandstr | cut -d\. -f2) # radio0

		#meshx0
		uci set wireless.meshx0=wifi-iface
		uci set wireless.meshx0.device="${radio}"
		uci set wireless.meshx0.network='lan'
		uci set wireless.meshx0.ifname='meshx0'
		uci set wireless.meshx0.mode='ap'
		uci set wireless.meshx0.wds='1'
		uci set wireless.meshx0.ssid="${id}"
		uci set wireless.meshx0.hidden='1'
		if test -n "$key"; then
			uci set wireless.meshx0.encryption='psk2'
			uci set wireless.meshx0.key="${key}"
		else
			uci set wireless.meshx0.encryption='none'
		fi
		uci set wireless.meshx0.skip_inactivity_poll='1'
		uci set wireless.meshx0.wpa_group_rekey='0'
		uci set wireless.meshx0.wpa_pair_rekey='0'
		uci set wireless.meshx0.wpa_master_rekey='0'
		uci set wireless.meshx0.disassoc_low_ack='0'

		#meshx1
		uci delete wireless.meshx1 >/dev/null 2>&1
	fi

	uci set dhcp.lan.ignore='0'
	uci delete dhcp.meshx0 >/dev/null 2>&1
	uci delete network.meshx0 >/dev/null 2>&1

	#re-enable wan
	uci delete network.wan.auto >/dev/null 2>&1
	uci delete network.wan6.auto >/dev/null 2>&1
	#del wan port from br-lan
	lan_idx=0
	while uci get network.@device[$lan_idx] >/dev/null 2>&1 && [ $(uci get network.@device[$lan_idx].name) != "br-lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_ports="$(uci get network.@device[$lan_idx].ports 2>/dev/null)"
	wan_port="$(uci get network.wan.device 2>/dev/null)"
	newlan_ports=$(for lp in $lan_ports; do [ "$lp" = "$wan_port" ] || echo $lp; done | sort | uniq)
	newlan_ports=$(echo $newlan_ports)
	[ "$lan_ports" != "$newlan_ports" ] && {
		uci delete network.@device[$lan_idx].ports >/dev/null 2>&1
		for lp in $newlan_ports; do
			uci add_list network.@device[$lan_idx].ports="$lp"
		done
	}

	#delete meshx0 from lan zone
	lan_idx=0
	while uci get firewall.@zone[$lan_idx] >/dev/null 2>&1 && [ $(uci get firewall.@zone[$lan_idx].name) != "lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_net="$(uci get firewall.@zone[$lan_idx].network 2>/dev/null)"
	newlan_net=$(for ln in $lan_net; do [ "$ln" = "meshx0" ] || echo $ln; done | sort | uniq)
	newlan_net=$(echo $newlan_net)
	[ "$lan_net" != "$newlan_net" ] && {
		uci delete firewall.@zone[$lan_idx].network >/dev/null 2>&1
		for ln in $newlan_net; do
			uci add_list firewall.@zone[$lan_idx].network="$ln"
		done
		uci commit firewall
	}

	# reload firewall
	uci get firewall.fakemesh >/dev/null 2>&1 || {
	uci -q batch <<-EOT
	delete firewall.fakemesh
	set firewall.fakemesh=include
	set firewall.fakemesh.type=script
	set firewall.fakemesh.path=/usr/share/fakemesh/firewall.include
	set firewall.fakemesh.family=any
	set firewall.fakemesh.reload=1
	commit firewall
	EOT
	}

	mkdir -p /usr/share/fakemesh
	cat >/tmp/fakemesh.firewall.include <<-EOT
#!/bin/sh
iptables -t nat -C prerouting_lan_rule -d $access_ip/32 -p tcp --dport 80 -j REDIRECT --to-ports 80 2>/dev/null || \
iptables -t nat -A prerouting_lan_rule -d $access_ip/32 -p tcp --dport 80 -j REDIRECT --to-ports 80
iptables -t nat -C prerouting_lan_rule -d $access_ip/32 -p tcp --dport 443 -j REDIRECT --to-ports 443 2>/dev/null || \
iptables -t nat -A prerouting_lan_rule -d $access_ip/32 -p tcp --dport 443 -j REDIRECT --to-ports 443

nft -a list chain inet fw4 dstnat | grep -o "fakemesh.*" | while read _ _ _ handle; do nft delete rule inet fw4 dstnat handle \$handle; done
nft insert rule inet fw4 dstnat iifname { \$(echo \$(fw4 -q zone lan | grep -v '*' | sort | uniq | sed 's/\(.*\)/"\1",/g') | sed 's/,$//') } ip daddr $access_ip/32 tcp dport 80 counter redirect to :80 comment "fakemesh"
nft insert rule inet fw4 dstnat iifname { \$(echo \$(fw4 -q zone lan | grep -v '*' | sort | uniq | sed 's/\(.*\)/"\1",/g') | sed 's/,$//') } ip daddr $access_ip/32 tcp dport 443 counter redirect to :443 comment "fakemesh"

EOT
	ln -s /tmp/fakemesh.firewall.include /usr/share/fakemesh/firewall.include 2>/dev/null
	grep -q "^sh /usr/share/fakemesh/firewall.include" /etc/firewall.include || echo "sh /usr/share/fakemesh/firewall.include" >>/etc/firewall.include

	grep -q "^$access_ip controller.fakemesh" /etc/hosts || {
		if grep -q ".* controller.fakemesh" /etc/hosts; then
			sed -i "s/.* controller.fakemesh/$access_ip controller.fakemesh/" /etc/hosts
		else
			echo "$access_ip controller.fakemesh" >>/etc/hosts
		fi
		/etc/init.d/dnsmasq reload
	}

	/etc/init.d/firewall reload >/dev/null 2>&1

	exec /usr/sbin/fakemesh gen_config &

	uci changes

	test $(uci changes 2>/dev/null | wc -l) -le 1 && {
		uci revert wireless
		uci revert dhcp
		uci revert network

		exec /usr/sbin/fakemesh agent_sync_config &
		exit 0
	}

	uci commit wireless
	uci commit dhcp
	uci commit network

	(sleep 15
	 /etc/init.d/network reload
	 /etc/init.d/dnsmasq reload
	 exec /usr/sbin/fakemesh agent_sync_config & )&
else

	# wireless.radio0.band='2g'
	wbandstr=$(uci show wireless | grep .band=\'${band}\'$ | head -n1)
	if test -n "$wbandstr"; then
		radio=$(echo $wbandstr | cut -d\. -f2) # radio0

		#meshx0
		uci set wireless.meshx0=wifi-iface
		uci set wireless.meshx0.device="${radio}"
		uci set wireless.meshx0.network='meshx0'
		uci set wireless.meshx0.ifname='meshx0'
		uci set wireless.meshx0.mode='ap'
		uci set wireless.meshx0.wds='1'
		uci set wireless.meshx0.ssid="${id}"
		uci set wireless.meshx0.hidden='1'
		if test -n "$key"; then
			uci set wireless.meshx0.encryption='psk2'
			uci set wireless.meshx0.key="${key}"
		else
			uci set wireless.meshx0.encryption='none'
		fi
		uci set wireless.meshx0.skip_inactivity_poll='1'
		uci set wireless.meshx0.wpa_group_rekey='0'
		uci set wireless.meshx0.wpa_pair_rekey='0'
		uci set wireless.meshx0.wpa_master_rekey='0'
		uci set wireless.meshx0.disassoc_low_ack='0'

		#meshx1
		uci set wireless.meshx1=wifi-iface
		uci set wireless.meshx1.device="${radio}"
		uci set wireless.meshx1.network='meshx0'
		uci set wireless.meshx1.ifname='meshx1'
		uci set wireless.meshx1.mode='sta'
		uci set wireless.meshx1.wds='1'
		uci set wireless.meshx1.ssid="${id}"
		if test -n "$key"; then
			uci set wireless.meshx1.encryption='psk2'
			uci set wireless.meshx1.key="${key}"
		else
			uci set wireless.meshx1.encryption='none'
		fi
		uci set wireless.meshx1.skip_inactivity_poll='1'
		uci set wireless.meshx1.wpa_group_rekey='0'
		uci set wireless.meshx1.wpa_pair_rekey='0'
		uci set wireless.meshx1.wpa_master_rekey='0'
		uci set wireless.meshx1.disassoc_low_ack='0'
		[ "$role" = "wap" ] && uci set wireless.meshx1.disabled='1'

		if [ "$band" = "5g" ]; then
			uci set wireless.${radio}.channel='36'
		else
			uci set wireless.${radio}.channel='1'
		fi
	fi

	uci set dhcp.lan.ignore='1'

	uci set dhcp.meshx0=dhcp
	uci set dhcp.meshx0.ignore='1'

	uci set network.lan.auto='0'

	uci set network.meshx0=interface
	uci set network.meshx0.device="$(uci get network.lan.device)"
	uci set network.meshx0.proto='dhcp'
	uci set network.meshx0.defaultroute='1'
	uci set network.meshx0.metric='10'
	uci set network.meshx0.hostname="MESH-AGENT_$(echo -n $MACADDR | sed 's/://g' | tr a-f A-F)"

	#add meshx0 to lan zone
	lan_idx=0
	while uci get firewall.@zone[$lan_idx] >/dev/null 2>&1 && [ $(uci get firewall.@zone[$lan_idx].name) != "lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_net="$(uci get firewall.@zone[$lan_idx].network 2>/dev/null)"
	newlan_net=$(for ln in $lan_net meshx0; do echo $ln; done | sort | uniq)
	newlan_net=$(echo $newlan_net)
	[ "$lan_net" != "$newlan_net" ] && {
		uci delete firewall.@zone[$lan_idx].network >/dev/null 2>&1
		for ln in $newlan_net; do
			uci add_list firewall.@zone[$lan_idx].network="$ln"
		done
		uci commit firewall
	}

	#disable wan
	uci set network.wan.auto='0' 2>/dev/null
	uci set network.wan6.auto='0' 2>/dev/null
	#add wan port to br-lan
	lan_idx=0
	while uci get network.@device[$lan_idx] >/dev/null 2>&1 && [ $(uci get network.@device[$lan_idx].name) != "br-lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_ports="$(uci get network.@device[$lan_idx].ports 2>/dev/null)"
	wan_port="$(uci get network.wan.device 2>/dev/null)"
	newlan_ports=$(for lp in $lan_ports $wan_port; do echo $lp; done | sort | uniq)
	newlan_ports=$(echo $newlan_ports)
	[ "$lan_ports" != "$newlan_ports" ] && {
		uci delete network.@device[$lan_idx].ports >/dev/null 2>&1
		for lp in $newlan_ports; do
			uci add_list network.@device[$lan_idx].ports="$lp"
		done
	}

	# reload firewall
	uci get firewall.fakemesh >/dev/null 2>&1 || {
		uci -q batch <<-EOT
		delete firewall.fakemesh
		set firewall.fakemesh=include
		set firewall.fakemesh.type=script
		set firewall.fakemesh.path=/usr/share/fakemesh/firewall.include
		set firewall.fakemesh.family=any
		set firewall.fakemesh.reload=1
		commit firewall
		EOT
	}

	mkdir -p /usr/share/fakemesh
	cat >/tmp/fakemesh.firewall.include <<-EOT
#!/bin/sh
iptables -t filter -C output_lan_rule -j MARK --set-xmark 0x00010000/0x00010000 2>/dev/null || \
iptables -t filter -A output_lan_rule -j MARK --set-xmark 0x00010000/0x00010000
iptables -t nat -C zone_lan_postrouting -m mark --mark 0x00010000/0x00010000 -j MASQUERADE 2>/dev/null || \
iptables -t nat -A zone_lan_postrouting -m mark --mark 0x00010000/0x00010000 -j MASQUERADE

nft -a list chain inet fw4 output_lan | grep -o "fakemesh_mark_0x10000.*" | while read _ _ _ handle; do nft delete rule inet fw4 output_lan handle \$handle; done
nft insert rule inet fw4 output_lan counter meta mark set mark or 0x10000 comment "fakemesh_mark_0x10000"

nft -a list chain inet fw4 srcnat | grep -o "fakemesh_mark_0x10000.*" | while read _ _ _ handle; do nft delete rule inet fw4 srcnat handle \$handle; done
nft insert rule inet fw4 srcnat oifname { \$(echo \$(fw4 -q zone lan | grep -v '*' | sort | uniq | sed 's/\(.*\)/"\1",/g') | sed 's/,$//') } mark and 0x10000 == 0x10000 counter masquerade comment "fakemesh_mark_0x10000"
EOT
	ln -s /tmp/fakemesh.firewall.include /usr/share/fakemesh/firewall.include 2>/dev/null
	grep -q "^sh /usr/share/fakemesh/firewall.include" /etc/firewall.include || echo "sh /usr/share/fakemesh/firewall.include" >>/etc/firewall.include

	/etc/init.d/firewall reload >/dev/null 2>&1

	uci changes

	test $(uci changes | wc -l) -le 5 && {
		uci revert wireless
		uci revert dhcp
		uci revert network

		exec /usr/sbin/fakemesh agent_fix_channel &
		exit 0
	}

	uci commit wireless
	uci commit dhcp
	uci commit network
	sed -i "/.* controller.fakemesh/d" /etc/hosts

	(sleep 15
	 /etc/init.d/network reload
	 /etc/init.d/dnsmasq reload
	 exec /usr/sbin/fakemesh agent_fix_channel & )&
fi
